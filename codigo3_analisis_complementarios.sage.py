"""
ANÁLISIS COMPLEMENTARIOS Y VERIFICACIÓN DE TEOREMAS
Operador: C_n^(3)(m) = n(n-m)(2n-m)(3n-m)

Este código genera datos y verifica teoremas del paper.
"""


# This file was *autogenerated* from the file codigo3_analisis_complementarios.sage
from sage.all_cmdline import *   # import sage library

_sage_const_80 = Integer(80); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_60 = Integer(60); _sage_const_1002 = Integer(1002); _sage_const_30 = Integer(30); _sage_const_100 = Integer(100); _sage_const_10 = Integer(10); _sage_const_102 = Integer(102); _sage_const_502 = Integer(502); _sage_const_53 = Integer(53); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_13 = Integer(13); _sage_const_14 = Integer(14); _sage_const_15 = Integer(15); _sage_const_20 = Integer(20); _sage_const_21 = Integer(21); _sage_const_22 = Integer(22); _sage_const_23 = Integer(23); _sage_const_24 = Integer(24); _sage_const_28 = Integer(28); _sage_const_29 = Integer(29); _sage_const_31 = Integer(31); _sage_const_34 = Integer(34); _sage_const_37 = Integer(37); _sage_const_38 = Integer(38); _sage_const_39 = Integer(39); _sage_const_41 = Integer(41); _sage_const_45 = Integer(45); _sage_const_46 = Integer(46); _sage_const_47 = Integer(47); _sage_const_52 = Integer(52); _sage_const_54 = Integer(54); _sage_const_55 = Integer(55); _sage_const_56 = Integer(56); _sage_const_61 = Integer(61); _sage_const_62 = Integer(62); _sage_const_63 = Integer(63); _sage_const_65 = Integer(65); _sage_const_69 = Integer(69); _sage_const_70 = Integer(70); _sage_const_71 = Integer(71); _sage_const_77 = Integer(77); _sage_const_78 = Integer(78); _sage_const_79 = Integer(79); _sage_const_84 = Integer(84); _sage_const_85 = Integer(85); _sage_const_86 = Integer(86); _sage_const_87 = Integer(87); _sage_const_88 = Integer(88); _sage_const_92 = Integer(92); _sage_const_93 = Integer(93); _sage_const_94 = Integer(94); _sage_const_95 = Integer(95); _sage_const_96 = Integer(96); _sage_const_101 = Integer(101); _sage_const_500 = Integer(500); _sage_const_16 = Integer(16); _sage_const_0p3 = RealNumber('0.3'); _sage_const_50 = Integer(50); _sage_const_0p6 = RealNumber('0.6'); _sage_const_11 = Integer(11); _sage_const_5000 = Integer(5000); _sage_const_0p5 = RealNumber('0.5'); _sage_const_0p7 = RealNumber('0.7'); _sage_const_4 = Integer(4); _sage_const_1000 = Integer(1000); _sage_const_90 = Integer(90); _sage_const_300 = Integer(300)
import pandas as pd
import numpy as np
from collections import defaultdict, Counter
from sage.all import *
import matplotlib.pyplot as plt
from scipy import stats
import time

print("="*_sage_const_80 )
print("ANÁLISIS COMPLEMENTARIOS - OPERADOR k=3")
print("="*_sage_const_80 )

# ============================================================================
# FUNCIONES AUXILIARES
# ============================================================================

def square_free_part(n):
    """Calcula la parte square-free de n"""
    if n == _sage_const_0 :
        return _sage_const_0 
    
    n = abs(int(n))
    result = _sage_const_1 
    temp = n
    
    p = _sage_const_2 
    while p * p <= temp:
        count = _sage_const_0 
        while temp % p == _sage_const_0 :
            count += _sage_const_1 
            temp //= p
        if count % _sage_const_2  == _sage_const_1 :
            result *= p
        p += _sage_const_1 
    
    if temp > _sage_const_1 :
        result *= temp
    
    return result

def operator_C3(n, m):
    """C_n^(3)(m) = n(n-m)(2n-m)(3n-m)"""
    if n <= m:
        return None
    return n * (n - m) * (_sage_const_2 *n - m) * (_sage_const_3 *n - m)

def euclidean_parameters(n, m):
    """u = 2n - m, v = n"""
    return _sage_const_2 *n - m, n

# ============================================================================
# 1. INVARIANTE SQUARE-FREE EN m = n/2
# ============================================================================

print("\n[1] Verificación: sf(C_n^(3)(n/2)) = 30 para n par")
print("-" * _sage_const_60 )

n_values = range(_sage_const_2 , _sage_const_1002 , _sage_const_2 )
resultados_invariante = []

for n in n_values:
    m = n // _sage_const_2 
    C_value = operator_C3(n, m)
    sf_value = square_free_part(C_value)
    resultados_invariante.append({
        'n': n,
        'm': m,
        'C_n^3(m)': C_value,
        'sf(C)': sf_value,
        'Verifica': sf_value == _sage_const_30 
    })

df_invariante = pd.DataFrame(resultados_invariante)

verificaciones = int(df_invariante['Verifica'].sum())
total = int(len(df_invariante))

print(f"Casos probados: {total}")
print(f"Verificaciones: {verificaciones}")
print(f"Tasa: {float(_sage_const_100 *verificaciones/total):.2f}%")

if verificaciones == total:
    print(f"✓ TEOREMA VERIFICADO")
else:
    print(f"✗ Anomalías detectadas")

print(f"\nEjemplos:")
print(df_invariante.head(int(_sage_const_10 ))[['n', 'm', 'C_n^3(m)', 'sf(C)', 'Verifica']])

# ============================================================================
# 2. CASOS FRONTERA (m = n-1)
# ============================================================================

print("\n[2] Verificación: C_n^(3)(n-1) = C_{n+1}^(2)(1)")
print("-" * _sage_const_60 )

n_range = range(_sage_const_2 , _sage_const_102 )
frontera_data = []

for n in n_range:
    C3_forward = n * (n + _sage_const_1 ) * (_sage_const_2 *n + _sage_const_1 )
    C2_backward = (n + _sage_const_1 ) * n * (_sage_const_2 *n + _sage_const_1 )
    
    frontera_data.append({
        'n': n,
        'C_n^(3)(n-1)': C3_forward,
        'C_{n+1}^(2)(1)': C2_backward,
        'Equivalentes': C3_forward == C2_backward
    })

df_frontera = pd.DataFrame(frontera_data)

verificaciones_frontera = int(df_frontera['Equivalentes'].sum())
print(f"Casos: {int(len(df_frontera))}")
print(f"Verificaciones: {verificaciones_frontera}")
print(f"Tasa: {float(_sage_const_100 *verificaciones_frontera/len(df_frontera)):.2f}%")

if verificaciones_frontera == len(df_frontera):
    print(f"✓ TEOREMA VERIFICADO")

print(f"\nEjemplos:")
print(df_frontera.head(int(_sage_const_10 ))[['n', 'C_n^(3)(n-1)', 'C_{n+1}^(2)(1)']])

# ============================================================================
# 3. ESPACIO (u,v)
# ============================================================================

print("\n[3] Análisis del espacio (u,v)")
print("-" * _sage_const_60 )

espacio_uv = []

for n in range(_sage_const_2 , _sage_const_502 ):
    for m in range(_sage_const_1 , n):
        u, v = euclidean_parameters(n, m)
        ratio_uv = u / v
        C_value = operator_C3(n, m)
        
        espacio_uv.append({
            'n': n,
            'm': m,
            'u': u,
            'v': v,
            'ratio_u/v': ratio_uv,
            'C_n^3(m)': C_value,
            'm/n': m/n
        })

df_uv = pd.DataFrame(espacio_uv)

print(f"Puntos: {int(len(df_uv)):,}")
print(f"Rango u: [{int(df_uv['u'].min())}, {int(df_uv['u'].max())}]")
print(f"Rango v: [{int(df_uv['v'].min())}, {int(df_uv['v'].max())}]")
print(f"Rango u/v: [{float(df_uv['ratio_u/v'].min()):.4f}, {float(df_uv['ratio_u/v'].max()):.4f}]")
print(f"Teórico u/v: (1, 2)")

ratio_min = float(df_uv['ratio_u/v'].min())
ratio_max = float(df_uv['ratio_u/v'].max())

if ratio_min > _sage_const_1  and ratio_max < _sage_const_2 :
    print(f"✓ Cobertura verificada")
else:
    print(f"⚠ Cobertura: [{ratio_min:.4f}, {ratio_max:.4f}]")

correlacion = float(df_uv['m/n'].corr(df_uv['ratio_u/v']))
print(f"\ncorr(m/n, u/v): {correlacion:.4f}")

df_uv['teorico_u/v'] = _sage_const_2  - df_uv['m/n']
error = float((df_uv['ratio_u/v'] - df_uv['teorico_u/v']).abs().max())
print(f"Error vs. u/v = 2 - m/n: {error:.2e}")

# ============================================================================
# 4. HERENCIA
# ============================================================================

print("\n[4] Verificación: C_n^(3)(m) = C_n^(2)(m) · (3n-m)")
print("-" * _sage_const_60 )

herencia_data = []

for n in range(_sage_const_3 , _sage_const_53 ):
    for m in range(_sage_const_1 , n):
        C2 = n * (n - m) * (_sage_const_2 *n - m)
        C3 = operator_C3(n, m)
        factor = _sage_const_3 *n - m
        
        herencia_data.append({
            'n': n,
            'm': m,
            'C_n^(2)(m)': C2,
            'C_n^(3)(m)': C3,
            'Factor': factor,
            'Verifica': (C3 == C2 * factor)
        })

df_herencia = pd.DataFrame(herencia_data)

verificaciones_herencia = int(df_herencia['Verifica'].sum())
print(f"Casos: {int(len(df_herencia)):,}")
print(f"Verificaciones: {verificaciones_herencia:,}")
print(f"Tasa: {float(_sage_const_100 *verificaciones_herencia/len(df_herencia)):.2f}%")

if verificaciones_herencia == len(df_herencia):
    print(f"✓ LEMA VERIFICADO")

# ============================================================================
# 5. COBERTURA OEIS (SIMULACIÓN)
# ============================================================================

print("\n[5] Simulación cobertura OEIS")
print("-" * _sage_const_60 )

congruent_oeis_sample = [_sage_const_5 , _sage_const_6 , _sage_const_7 , _sage_const_13 , _sage_const_14 , _sage_const_15 , _sage_const_20 , _sage_const_21 , _sage_const_22 , _sage_const_23 , _sage_const_24 , _sage_const_28 , _sage_const_29 , _sage_const_30 ,
                          _sage_const_31 , _sage_const_34 , _sage_const_37 , _sage_const_38 , _sage_const_39 , _sage_const_41 , _sage_const_45 , _sage_const_46 , _sage_const_47 , _sage_const_52 , _sage_const_53 , _sage_const_54 , _sage_const_55 ,
                          _sage_const_56 , _sage_const_60 , _sage_const_61 , _sage_const_62 , _sage_const_63 , _sage_const_65 , _sage_const_69 , _sage_const_70 , _sage_const_71 , _sage_const_77 , _sage_const_78 , _sage_const_79 , _sage_const_80 ,
                          _sage_const_84 , _sage_const_85 , _sage_const_86 , _sage_const_87 , _sage_const_88 , _sage_const_92 , _sage_const_93 , _sage_const_94 , _sage_const_95 , _sage_const_96 , _sage_const_101 , _sage_const_102 ]

print(f"Muestra OEIS: {int(len(congruent_oeis_sample))} números")

n_max = _sage_const_500 
generados = set()

print(f"Generando con n ≤ {int(n_max)}...")
for n in range(_sage_const_2 , n_max+_sage_const_1 ):
    for m in range(_sage_const_1 , n):
        C_value = operator_C3(n, m)
        sf = square_free_part(C_value)
        generados.add(sf)

print(f"Cores únicos: {int(len(generados))}")

cobertura = [num for num in congruent_oeis_sample if num in generados]
no_cubiertos = [num for num in congruent_oeis_sample if num not in generados]

print(f"\nCubiertos: {int(len(cobertura))} / {int(len(congruent_oeis_sample))}")
print(f"Tasa: {float(_sage_const_100 *len(cobertura)/len(congruent_oeis_sample)):.2f}%")
print(f"No cubiertos: {no_cubiertos[:_sage_const_20 ]}")

# ============================================================================
# 6. CASO DEGENERADO n=2
# ============================================================================

print("\n[6] Caso degenerado n=2")
print("-" * _sage_const_60 )

n = _sage_const_2 
m = _sage_const_1 
C_value = operator_C3(n, m)

print(f"n = {int(n)}, m = {int(m)}")
print(f"Dominio: [1, n-1] = [1, 1] = {{1}}")
print(f"m_mid = n/2 = {int(n//_sage_const_2 )}")
print(f"Todos coinciden: {m == n//_sage_const_2  == n-_sage_const_1 }")
print(f"C_2^(3)(1) = {int(C_value)}")
print(f"sf = {int(square_free_part(C_value))}")

if C_value == _sage_const_30  and square_free_part(C_value) == _sage_const_30 :
    print(f"✓ VERIFICADO")

# ============================================================================
# 7. VISUALIZACIONES
# ============================================================================

print("\n[7] Generando visualizaciones...")

fig = plt.figure(figsize=(_sage_const_16 , _sage_const_10 ))
gs = fig.add_gridspec(_sage_const_2 , _sage_const_3 , hspace=_sage_const_0p3 , wspace=_sage_const_0p3 )

# 1. Invariante
ax1 = fig.add_subplot(gs[_sage_const_0 , _sage_const_0 ])
n_sample = df_invariante['n'].values[:_sage_const_50 ]
sf_sample = df_invariante['sf(C)'].values[:_sage_const_50 ]
ax1.scatter(n_sample, sf_sample, alpha=_sage_const_0p6 )
ax1.axhline(y=_sage_const_30 , color='red', linestyle='--', linewidth=_sage_const_2 , label='sf = 30')
ax1.set_xlabel('n (par)', fontsize=_sage_const_10 )
ax1.set_ylabel('sf(C_n^(3)(n/2))', fontsize=_sage_const_10 )
ax1.set_title('Invariante SF', fontsize=_sage_const_11 , fontweight='bold')
ax1.legend()
ax1.grid(alpha=_sage_const_0p3 )

# 2. Espacio (u,v)
ax2 = fig.add_subplot(gs[_sage_const_0 , _sage_const_1 ])
sample_uv = df_uv.sample(int(min(_sage_const_5000 , len(df_uv))))
scatter = ax2.scatter(sample_uv['ratio_u/v'], sample_uv['m/n'], 
                     c=sample_uv['v'], cmap='viridis', alpha=_sage_const_0p5 , s=_sage_const_10 )
ax2.axvline(x=_sage_const_1 , color='red', linestyle='--', alpha=_sage_const_0p7 )
ax2.axvline(x=_sage_const_2 , color='red', linestyle='--', alpha=_sage_const_0p7 )
ax2.set_xlabel('u/v', fontsize=_sage_const_10 )
ax2.set_ylabel('m/n', fontsize=_sage_const_10 )
ax2.set_title('Espacio (u/v, m/n)', fontsize=_sage_const_11 , fontweight='bold')
plt.colorbar(scatter, ax=ax2, label='v')
ax2.grid(alpha=_sage_const_0p3 )

# 3. Relación teórica
ax3 = fig.add_subplot(gs[_sage_const_0 , _sage_const_2 ])
ax3.scatter(df_uv['m/n'], df_uv['ratio_u/v'], alpha=_sage_const_0p3 , s=_sage_const_5 )
x = np.linspace(_sage_const_0 , _sage_const_1 , _sage_const_100 )
y = _sage_const_2  - x
ax3.plot(x, y, 'r-', linewidth=_sage_const_2 , label='u/v = 2 - m/n')
ax3.set_xlabel('m/n', fontsize=_sage_const_10 )
ax3.set_ylabel('u/v', fontsize=_sage_const_10 )
ax3.set_title('Relación Teórica', fontsize=_sage_const_11 , fontweight='bold')
ax3.legend()
ax3.grid(alpha=_sage_const_0p3 )

# 4. Frontera
ax4 = fig.add_subplot(gs[_sage_const_1 , _sage_const_0 ])
n_front = df_frontera['n'].values[:_sage_const_30 ]
# Convertir a float antes de aplicar log10
C3_vals = [float(x) for x in df_frontera['C_n^(3)(n-1)'].values[:_sage_const_30 ]]
C2_vals = [float(x) for x in df_frontera['C_{n+1}^(2)(1)'].values[:_sage_const_30 ]]
C3 = np.log10(C3_vals)
C2 = np.log10(C2_vals)
ax4.plot(n_front, C3, 'o-', label='C_n^(3)(n-1)', markersize=_sage_const_4 )
ax4.plot(n_front, C2, 's--', label='C_{n+1}^(2)(1)', markersize=_sage_const_4 )
ax4.set_xlabel('n', fontsize=_sage_const_10 )
ax4.set_ylabel('log₁₀(C)', fontsize=_sage_const_10 )
ax4.set_title('Equivalencia Frontera', fontsize=_sage_const_11 , fontweight='bold')
ax4.legend()
ax4.grid(alpha=_sage_const_0p3 )

# 5. SF cores
ax5 = fig.add_subplot(gs[_sage_const_1 , _sage_const_1 ])
sf_cores = [square_free_part(operator_C3(n, m)) 
            for n in range(_sage_const_2 , _sage_const_102 ) for m in range(_sage_const_1 , int(min(n, _sage_const_20 )))]
sf_cores = [x for x in sf_cores if x < _sage_const_1000 ]
ax5.hist(sf_cores, bins=_sage_const_50 , edgecolor='black', alpha=_sage_const_0p7 , color='teal')
ax5.set_xlabel('Square-free core', fontsize=_sage_const_10 )
ax5.set_ylabel('Frecuencia', fontsize=_sage_const_10 )
ax5.set_title('Distribución SF Cores', fontsize=_sage_const_11 , fontweight='bold')
ax5.set_yscale('log')
ax5.grid(alpha=_sage_const_0p3 , axis='y')

# 6. Cobertura
ax6 = fig.add_subplot(gs[_sage_const_1 , _sage_const_2 ])
categorias = ['Cubiertos', 'No cubiertos']
valores = [len(cobertura), len(no_cubiertos)]
colors = ['#2ecc71', '#e74c3c']
ax6.pie(valores, labels=categorias, autopct='%1.1f%%', colors=colors, startangle=_sage_const_90 )
ax6.set_title(f'Cobertura OEIS (n≤{n_max})', fontsize=_sage_const_11 , fontweight='bold')

plt.savefig('analisis_complementarios.png', dpi=_sage_const_300 , bbox_inches='tight')
print("✓ Guardado: analisis_complementarios.png")

# ============================================================================
# 8. EXPORTAR
# ============================================================================

print("\n[8] Exportando...")

df_invariante.to_csv('verificacion_invariante_sf.csv', index=False)
df_frontera.to_csv('verificacion_frontera.csv', index=False)
df_uv.to_csv('espacio_parametrico_uv.csv', index=False)

with open('verificacion_teoremas.txt', 'w', encoding='utf-8') as f:
    f.write("="*_sage_const_80  + "\n")
    f.write("VERIFICACIÓN DE TEOREMAS - OPERADOR k=3\n")
    f.write("="*_sage_const_80  + "\n\n")
    
    f.write("1. INVARIANTE SF (m = n/2):\n")
    f.write(f"   Tasa: {float(_sage_const_100 *verificaciones/total):.2f}%\n")
    f.write(f"   Estado: {'✓ VERIFICADO' if verificaciones == total else '✗ FALLO'}\n\n")
    
    f.write("2. FRONTERA (m = n-1):\n")
    f.write(f"   Tasa: {float(_sage_const_100 *verificaciones_frontera/len(df_frontera)):.2f}%\n")
    f.write(f"   Estado: {'✓ VERIFICADO' if verificaciones_frontera == len(df_frontera) else '✗ FALLO'}\n\n")
    
    f.write("3. ESPACIO (u,v):\n")
    f.write(f"   Rango: [{ratio_min:.4f}, {ratio_max:.4f}]\n")
    f.write(f"   Teórico: (1, 2)\n")
    f.write(f"   Estado: {'✓ VERIFICADO' if ratio_min > _sage_const_1  and ratio_max < _sage_const_2  else '⚠ EXTENDIDO'}\n\n")
    
    f.write("4. HERENCIA:\n")
    f.write(f"   Tasa: {float(_sage_const_100 *verificaciones_herencia/len(df_herencia)):.2f}%\n")
    f.write(f"   Estado: {'✓ VERIFICADO' if verificaciones_herencia == len(df_herencia) else '✗ FALLO'}\n\n")
    
    f.write(f"5. COBERTURA OEIS (n ≤ {int(n_max)}):\n")
    f.write(f"   Cubiertos: {int(len(cobertura))} / {int(len(congruent_oeis_sample))}\n")
    f.write(f"   Tasa: {float(_sage_const_100 *len(cobertura)/len(congruent_oeis_sample)):.2f}%\n")

print("✓ Archivos generados:")
print("  • analisis_complementarios.png")
print("  • verificacion_invariante_sf.csv")
print("  • verificacion_frontera.csv")
print("  • espacio_parametrico_uv.csv")
print("  • verificacion_teoremas.txt")

print("\n" + "="*_sage_const_80 )
print("ANÁLISIS COMPLETADO")
print("="*_sage_const_80 )


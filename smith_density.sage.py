

# This file was *autogenerated* from the file smith_density.sage
from sage.all_cmdline import *   # import sage library

_sage_const_8 = Integer(8); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_50 = Integer(50); _sage_const_55p9 = RealNumber('55.9'); _sage_const_41p9 = RealNumber('41.9')# --- SAGE SCRIPT: RESIDUE AUDIT VS. SMITH THEOREMS (FIXED) ---
import pandas as pd

# 1. Cargar la base optimizada de núcleos square-free
try:
    df_cores = pd.read_csv("lista_608_squarefree.csv")
    # Intentar detectar la columna correcta (Stata suele exportar N_pure o n)
    possible_cols = ['N_pure', 'n', 'N', 'n_pure']
    col_n = next((c for c in possible_cols if c in df_cores.columns), None)
    
    if col_n:
        df_cores['N_val'] = df_cores[col_n].apply(lambda x: int(float(x)))
    else:
        print("Error: No se encontró una columna de valores (n, N_pure) en el CSV.")
except Exception as e:
    print(f"Error al cargar el archivo: {e}")

def analyze_smith_bounds(df):
    total = len(df)
    # Calculamos el residuo mod 8
    df['mod8'] = df['N_val'] % _sage_const_8 
    counts = df['mod8'].value_counts()
    
    # Grupos de Alexander Smith
    group_A = [_sage_const_1 , _sage_const_2 , _sage_const_3 ] # Smith Bound: > 41.9%
    group_B = [_sage_const_5 , _sage_const_6 , _sage_const_7 ] # Smith Bound: > 55.9%
    
    hits_A = sum(counts.get(r, _sage_const_0 ) for r in group_A)
    hits_B = sum(counts.get(r, _sage_const_0 ) for r in group_B)
    
    # Convertimos explícitamente a float de Python para evitar el error de Sage
    prop_A = float(hits_A / total) * _sage_const_100 
    prop_B = float(hits_B / total) * _sage_const_100 
    
    print("-" * _sage_const_50 )
    print(f"--- SMITH THEOREM AUDIT (N={total}) ---")
    print("-" * _sage_const_50 )
    # El formateo :.2f ahora funcionará correctamente
    print(f"Group A {group_A} mod 8: {prop_A:.2f}% (Smith Bound: 41.9%)")
    print(f"Group B {group_B} mod 8: {prop_B:.2f}% (Smith Bound: 55.9%)")
    print("-" * _sage_const_50 )
    
    # Validación de Sesgo Aritmético
    if prop_B > _sage_const_55p9 :
        print("STATUS: SUCCESS. Operator exceeds Smith's lower bound for Group B.")
    if prop_A > _sage_const_41p9 :
        print("STATUS: SUCCESS. Operator exceeds Smith's lower bound for Group A.")
    
    # Mostrar distribución detallada para el artículo
    print("\nDetailed Residue Distribution:")
    for r in range(_sage_const_8 ):
        c = counts.get(r, _sage_const_0 )
        p = float(c / total) * _sage_const_100 
        print(f"Mod 8 == {r}: {c} hits ({p:.2f}%)")

if 'df_cores' in locals():
    analyze_smith_bounds(df_cores)


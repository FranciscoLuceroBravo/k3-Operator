"""
ANÁLISIS MODULAR EXTENSIVO - OPERADOR MULTIFACTORIAL k=3
Dataset: db_k3_no_restric_autosave.csv (~12M resultados)
Columnas: N (resultado operador), n, m (parámetros), Ratio_m_n

Operador: C_n^(3)(m) = n(n-m)(2n-m)(3n-m)
"""


# This file was *autogenerated* from the file codigo2_analisis_modular.sage
from sage.all_cmdline import *   # import sage library

_sage_const_80 = Integer(80); _sage_const_500000 = Integer(500000); _sage_const_1 = Integer(1); _sage_const_23 = Integer(23); _sage_const_1024 = Integer(1024); _sage_const_2 = Integer(2); _sage_const_10 = Integer(10); _sage_const_1000000 = Integer(1000000); _sage_const_60 = Integer(60); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_8 = Integer(8); _sage_const_12 = Integer(12); _sage_const_24 = Integer(24); _sage_const_100 = Integer(100); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_11 = Integer(11); _sage_const_13 = Integer(13); _sage_const_16 = Integer(16); _sage_const_100000 = Integer(100000); _sage_const_50 = Integer(50); _sage_const_10000 = Integer(10000); _sage_const_300 = Integer(300); _sage_const_40 = Integer(40)

# This file was *autogenerated* from the file codigo2_analisis_modular.sage
from sage.all_cmdline import *   # import sage library

_sage_const_80 = Integer(_sage_const_80 ); _sage_const_500000 = Integer(_sage_const_500000 ); _sage_const_1 = Integer(_sage_const_1 ); _sage_const_23 = Integer(_sage_const_23 ); _sage_const_1024 = Integer(_sage_const_1024 ); _sage_const_2 = Integer(_sage_const_2 ); _sage_const_10 = Integer(_sage_const_10 ); _sage_const_1000000 = Integer(_sage_const_1000000 ); _sage_const_60 = Integer(_sage_const_60 ); _sage_const_3 = Integer(_sage_const_3 ); _sage_const_4 = Integer(_sage_const_4 ); _sage_const_5 = Integer(_sage_const_5 ); _sage_const_6 = Integer(_sage_const_6 ); _sage_const_8 = Integer(_sage_const_8 ); _sage_const_12 = Integer(_sage_const_12 ); _sage_const_24 = Integer(_sage_const_24 ); _sage_const_100 = Integer(_sage_const_100 ); _sage_const_0 = Integer(_sage_const_0 ); _sage_const_0p001 = RealNumber('0.001'); _sage_const_0p25 = RealNumber('0.25'); _sage_const_0p5 = RealNumber('0.5'); _sage_const_0p75 = RealNumber('0.75'); _sage_const_1p0 = RealNumber('1.0'); _sage_const_7 = Integer(_sage_const_7 ); _sage_const_11 = Integer(_sage_const_11 ); _sage_const_13 = Integer(_sage_const_13 ); _sage_const_16 = Integer(_sage_const_16 ); _sage_const_0p3 = RealNumber('0.3'); _sage_const_0p7 = RealNumber('0.7'); _sage_const_100000 = Integer(_sage_const_100000 ); _sage_const_50 = Integer(_sage_const_50 ); _sage_const_10000 = Integer(_sage_const_10000 ); _sage_const_300 = Integer(_sage_const_300 ); _sage_const_40 = Integer(_sage_const_40 )
import csv
import pandas as pd
import numpy as np
from collections import defaultdict, Counter
from sage.all import *
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
import time

print("="*int(_sage_const_80))
print("ANÁLISIS MODULAR EXTENSIVO - OPERADOR k=3")
print("="*int(_sage_const_80))

# ============================================================================
# 1. CARGA DE DATOS
# ============================================================================

print("\n[1] Cargando datos desde db_k3_no_restric_autosave.csv...")
print("(Esto puede tomar varios minutos)")

start_time = time.time()

try:
    chunk_size = int(_sage_const_500000)  # CORRECCIÓN: Convertir a int de Python
    chunks = []
    
    for i, chunk in enumerate(pd.read_csv('db_k3_no_restric_autosave.csv', chunksize=chunk_size)):
        chunks.append(chunk)
        print(f"  Chunk {i+_sage_const_1 }: {len(chunk):,} registros")
        if i >= int(_sage_const_23):  # CORRECCIÓN: Convertir a int
            break
    
    df = pd.concat(chunks, ignore_index=True)
    load_time = time.time() - start_time
    
    print(f"\n✓ Cargados: {len(df):,} registros en {float(load_time):.2f}s")
    print(f"✓ Columnas: {list(df.columns)}")
    print(f"✓ Memoria: {float(df.memory_usage(deep=True).sum() / int(_sage_const_1024) ** _sage_const_2 ):.2f} MB")  # CORRECCIÓN
    print(f"\nPrimeras filas:")
    print(df.head(int(_sage_const_10)))  # CORRECCIÓN
    
except Exception as e:
    print(f"✗ Error: {e}")
    try:
        df = pd.read_csv('db_k3_no_restric_autosave.csv', nrows=int(_sage_const_1000000))  # CORRECCIÓN
        print(f"✓ Carga limitada: {len(df):,} registros")
    except:
        print("✗ No se pudo cargar.")
        exit(int(_sage_const_1))  # CORRECCIÓN

# ============================================================================
# 2. EXTRAER DATOS RELEVANTES
# ============================================================================

print("\n[2] Extrayendo columnas relevantes...")

# N: resultado del operador C_n^(3)(m)
valores = df['N'].values
n_values = df['n'].values
m_values = df['m'].values
ratio_mn = df['Ratio_m_n'].values

print(f"✓ Valores del operador (N): {len(valores):,}")
print(f"  Rango: [{int(valores.min()):,}, {int(valores.max()):,}]")
print(f"✓ Parámetro n: rango [{int(n_values.min())}, {int(n_values.max())}]")
print(f"✓ Parámetro m: rango [{int(m_values.min())}, {int(m_values.max())}]")
print(f"✓ Ratio m/n: rango [{float(ratio_mn.min()):.4f}, {float(ratio_mn.max()):.4f}]")

# ============================================================================
# 3. ANÁLISIS MODULAR
# ============================================================================

print("\n[3] Análisis de residuos modulares...")
print("-" * int(_sage_const_60))

modulos_analisis = [_sage_const_2 , _sage_const_3 , _sage_const_4 , _sage_const_5 , _sage_const_6 , _sage_const_8 , _sage_const_10 , _sage_const_12 , _sage_const_24 ]  # CORRECCIÓN: Usar enteros de Python directamente
resultados_modulares = {}

for mod in modulos_analisis:
    residuos = valores % mod
    distribucion = Counter(residuos)
    resultados_modulares[mod] = distribucion
    
    print(f"\nMódulo {mod}:")
    print(f"  Residuos: {sorted(distribucion.keys())}")
    
    total = len(valores)
    for residuo in sorted(distribucion.keys()):
        count = int(distribucion[residuo])
        porcentaje = float(_sage_const_100  * count / total)  # CORRECCIÓN: float()
        teorico = float(_sage_const_100  / mod)  # CORRECCIÓN: float()
        desviacion = float(porcentaje - teorico)  # CORRECCIÓN: float()
        print(f"    {residuo:2d} ≡ (mod {mod:2d}): {count:>10,} ({porcentaje:>6.2f}%) "
              f"[Teórico: {teorico:.2f}%, Δ: {desviacion:+.2f}%]")

# ============================================================================
# 4. ANÁLISIS MOD 6 (NÚMEROS CONGRUENTES)
# ============================================================================

print("\n[4] Análisis detallado mod 6:")
print("-" * int(_sage_const_60))

residuos_mod6 = valores % _sage_const_6   # CORRECCIÓN: Entero de Python
dist_mod6 = Counter(residuos_mod6)

print("Distribución mod 6:")
for r in range(_sage_const_6 ):  # CORRECCIÓN: Entero de Python
    count = int(dist_mod6.get(r, _sage_const_0 ))  # CORRECCIÓN: Entero de Python
    porcentaje = float(_sage_const_100  * count / len(valores))  # CORRECCIÓN: float()
    print(f"  {r} ≡ (mod 6): {count:>10,} ({porcentaje:>6.2f}%)")

observado = [dist_mod6.get(i, _sage_const_0 ) for i in range(_sage_const_6 )]
esperado = [len(valores) / _sage_const_6 ] * _sage_const_6 
chi2, p_value = stats.chisquare(observado, esperado)

print(f"\nTest Chi-cuadrado:")
print(f"  χ² = {float(chi2):.2f}")
print(f"  p-value = {float(p_value):.2e}")
print(f"  {'NO uniforme' if p_value < float(_sage_const_0p001) else 'Uniforme'}")  # CORRECCIÓN: float()

clase_dominante = max(dist_mod6.items(), key=lambda x: x[_sage_const_1 ])
print(f"\nClase dominante: {clase_dominante[_sage_const_0 ]} ≡ (mod 6)")
print(f"Concentración: {float(_sage_const_100  * clase_dominante[_sage_const_1 ]/len(valores)):.2f}%")  # CORRECCIÓN: float()

# ============================================================================
# 5. ANÁLISIS MOD 8
# ============================================================================

print("\n[5] Análisis mod 8:")
print("-" * int(_sage_const_60))

residuos_mod8 = valores % _sage_const_8   # CORRECCIÓN: Entero de Python
dist_mod8 = Counter(residuos_mod8)

print("Distribución mod 8:")
for r in range(_sage_const_8 ):  # CORRECCIÓN: Entero de Python
    count = int(dist_mod8.get(r, _sage_const_0 ))  # CORRECCIÓN: Entero de Python
    porcentaje = float(_sage_const_100  * count / len(valores))  # CORRECCIÓN: float()
    print(f"  {r} ≡ (mod 8): {count:>10,} ({porcentaje:>6.2f}%)")

# ============================================================================
# 6. ANÁLISIS DEL RATIO m/n
# ============================================================================

print("\n[6] Análisis del ratio m/n:")
print("-" * int(_sage_const_60))

print(f"Estadísticas:")
print(f"  Media: {float(np.mean(ratio_mn)):.4f}")
print(f"  Mediana: {float(np.median(ratio_mn)):.4f}")
print(f"  Desv. estándar: {float(np.std(ratio_mn)):.4f}")
print(f"  Mínimo: {float(np.min(ratio_mn)):.4f}")
print(f"  Máximo: {float(np.max(ratio_mn)):.4f}")
print(f"  Skewness: {float(stats.skew(ratio_mn)):.4f}")
print(f"  Kurtosis: {float(stats.kurtosis(ratio_mn)):.4f}")

quartiles = np.quantile(ratio_mn, [float(_sage_const_0p25), float(_sage_const_0p5), float(_sage_const_0p75)])  # CORRECCIÓN: float()
print(f"\nCuartiles:")
print(f"  Q1 (25%): {float(quartiles[_sage_const_0 ]):.4f}")
print(f"  Q2 (50%): {float(quartiles[_sage_const_1 ]):.4f}")
print(f"  Q3 (75%): {float(quartiles[_sage_const_2 ]):.4f}")

# Análisis modular por bins de ratio
print(f"\nAnálisis modular por ratio m/n:")
bins = [_sage_const_0 , float(_sage_const_0p25), float(_sage_const_0p5), float(_sage_const_0p75), float(_sage_const_1p0)]  # CORRECCIÓN: float()
labels = ['0-0.25', '0.25-0.5', '0.5-0.75', '0.75-1']

for i in range(len(bins)-_sage_const_1 ):
    mask = (ratio_mn >= bins[i]) & (ratio_mn < bins[i+_sage_const_1 ])
    subset_valores = valores[mask]
    
    if len(subset_valores) > _sage_const_0 :
        res_mod6 = subset_valores % _sage_const_6 
        dist = Counter(res_mod6)
        dominante = max(dist.items(), key=lambda x: x[_sage_const_1 ])
        print(f"\n  Ratio {labels[i]}:")
        print(f"    Tamaño: {len(subset_valores):,}")
        print(f"    Clase mod 6 dominante: {dominante[_sage_const_0 ]} ({float(_sage_const_100  * dominante[_sage_const_1 ]/len(subset_valores)):.1f}%)")  # CORRECCIÓN: float()

# ============================================================================
# 7. PARIDAD Y DIVISIBILIDAD
# ============================================================================

print("\n[7] Propiedades aritméticas:")
print("-" * int(_sage_const_60))

pares = int(np.sum(valores % _sage_const_2  == _sage_const_0 ))
impares = int(np.sum(valores % _sage_const_2  == _sage_const_1 ))
print(f"\nParidad:")
print(f"  Pares: {pares:,} ({float(_sage_const_100  * pares/len(valores)):.2f}%)")
print(f"  Impares: {impares:,} ({float(_sage_const_100  * impares/len(valores)):.2f}%)")

primos = [_sage_const_2 , _sage_const_3 , _sage_const_5 , _sage_const_7 , _sage_const_11 , _sage_const_13 ]  # CORRECCIÓN: Enteros de Python
print(f"\nDivisibilidad por primos:")
for p in primos:
    divisibles = int(np.sum(valores % p == _sage_const_0 ))
    porcentaje = float(_sage_const_100  * divisibles / len(valores))  # CORRECCIÓN: float()
    teorico = float(_sage_const_100  / p)  # CORRECCIÓN: float()
    print(f"  Divisibles por {p:2d}: {divisibles:>10,} ({porcentaje:>6.2f}%) "
          f"[Teórico: {teorico:.2f}%]")

# ============================================================================
# 8. CORRELACIÓN ENTRE PARÁMETROS
# ============================================================================

print("\n[8] Correlaciones:")
print("-" * int(_sage_const_60))

# Calcular u, v (parametrización euclidiana)
u_values = _sage_const_2  * n_values - m_values  # CORRECCIÓN: Entero de Python
v_values = n_values
ratio_uv = u_values / v_values

print(f"Parámetros euclidianos:")
print(f"  u = 2n - m: rango [{float(np.min(u_values)):.0f}, {float(np.max(u_values)):.0f}]")
print(f"  v = n: rango [{int(np.min(v_values))}, {int(np.max(v_values))}]")
print(f"  u/v: rango [{float(np.min(ratio_uv)):.4f}, {float(np.max(ratio_uv)):.4f}]")
print(f"  Rango teórico u/v: (1, 2)")

# Correlaciones
corr_nm = float(np.corrcoef(n_values, m_values)[_sage_const_0 , _sage_const_1 ])
corr_ratio_uv_mn = float(np.corrcoef(ratio_uv, ratio_mn)[_sage_const_0 , _sage_const_1 ])

print(f"\nCorrelaciones:")
print(f"  corr(n, m): {corr_nm:.4f}")
print(f"  corr(u/v, m/n): {corr_ratio_uv_mn:.4f}")

# Verificar relación teórica: u/v = 2 - m/n
teorico_uv = _sage_const_2  - ratio_mn  # CORRECCIÓN: Entero de Python
error = np.abs(ratio_uv - teorico_uv).max()
print(f"\nVerificación u/v = 2 - m/n:")
print(f"  Error máximo: {float(error):.2e}")

# ============================================================================
# 9. VISUALIZACIONES
# ============================================================================

print("\n[9] Generando visualizaciones...")

fig = plt.figure(figsize=(int(_sage_const_16), int(_sage_const_12)))  # CORRECCIÓN: int()
gs = fig.add_gridspec(int(_sage_const_3), int(_sage_const_3), hspace=float(_sage_const_0p3), wspace=float(_sage_const_0p3))  # CORRECCIÓN: int() y float()

# 1. Mod 6
ax1 = fig.add_subplot(gs[_sage_const_0 , _sage_const_0 ])
residuos = list(range(_sage_const_6 ))  # CORRECCIÓN: Entero de Python
freqs = [int(dist_mod6.get(r, _sage_const_0 )) for r in residuos]
ax1.bar(residuos, freqs, color='steelblue', edgecolor='black')
ax1.axhline(y=len(valores)/_sage_const_6 , color='red', linestyle='--', label='Uniforme')  # CORRECCIÓN: Entero de Python
ax1.set_xlabel('Residuo mod 6', fontsize=int(_sage_const_10))  # CORRECCIÓN: int()
ax1.set_ylabel('Frecuencia', fontsize=int(_sage_const_10))
ax1.set_title('Distribución mod 6', fontsize=int(_sage_const_11), fontweight='bold')
ax1.legend()
ax1.grid(alpha=float(_sage_const_0p3), axis='y')  # CORRECCIÓN: float()

# 2. Mod 8
ax2 = fig.add_subplot(gs[_sage_const_0 , _sage_const_1 ])
residuos8 = list(range(_sage_const_8 ))  # CORRECCIÓN: Entero de Python
freqs8 = [int(dist_mod8.get(r, _sage_const_0 )) for r in residuos8]
ax2.bar(residuos8, freqs8, color='coral', edgecolor='black')
ax2.axhline(y=len(valores)/_sage_const_8 , color='red', linestyle='--', label='Uniforme')  # CORRECCIÓN: Entero de Python
ax2.set_xlabel('Residuo mod 8', fontsize=int(_sage_const_10))
ax2.set_ylabel('Frecuencia', fontsize=int(_sage_const_10))
ax2.set_title('Distribución mod 8', fontsize=int(_sage_const_11), fontweight='bold')
ax2.legend()
ax2.grid(alpha=float(_sage_const_0p3), axis='y')  # CORRECCIÓN: float()

# 3. Mod 12
ax3 = fig.add_subplot(gs[_sage_const_0 , _sage_const_2 ])
residuos_mod12 = valores % _sage_const_12   # CORRECCIÓN: Entero de Python
dist_mod12 = Counter(residuos_mod12)
residuos12 = list(range(_sage_const_12 ))  # CORRECCIÓN: Entero de Python
freqs12 = [int(dist_mod12.get(r, _sage_const_0 )) for r in residuos12]
ax3.bar(residuos12, freqs12, color='seagreen', edgecolor='black')
ax3.axhline(y=len(valores)/_sage_const_12 , color='red', linestyle='--', label='Uniforme')  # CORRECCIÓN: Entero de Python
ax3.set_xlabel('Residuo mod 12', fontsize=int(_sage_const_10))
ax3.set_ylabel('Frecuencia', fontsize=int(_sage_const_10))
ax3.set_title('Distribución mod 12', fontsize=int(_sage_const_11), fontweight='bold')
ax3.legend()
ax3.grid(alpha=float(_sage_const_0p3), axis='y')  # CORRECCIÓN: float()

# 4. Chi-cuadrado por módulo
ax4 = fig.add_subplot(gs[_sage_const_1 , :_sage_const_2 ])
chi2_vals = []
for mod in modulos_analisis:
    res = valores % mod
    obs = [Counter(res).get(i, _sage_const_0 ) for i in range(mod)]
    esp = [len(valores) / mod] * mod
    chi2_val, _ = stats.chisquare(obs, esp)
    chi2_vals.append(float(chi2_val))  # CORRECCIÓN: float()

ax4.bar(range(len(modulos_analisis)), chi2_vals, color='purple', alpha=float(_sage_const_0p7), edgecolor='black')  # CORRECCIÓN: float()
ax4.set_xticks(range(len(modulos_analisis)))
ax4.set_xticklabels([str(m) for m in modulos_analisis])
ax4.set_xlabel('Módulo', fontsize=int(_sage_const_10))
ax4.set_ylabel('χ²', fontsize=int(_sage_const_10))
ax4.set_title('Desviación de Uniformidad', fontsize=int(_sage_const_11), fontweight='bold')
ax4.grid(alpha=float(_sage_const_0p3), axis='y')  # CORRECCIÓN: float()

# 5. Ratio m/n
ax5 = fig.add_subplot(gs[_sage_const_1 , _sage_const_2 ])
sample = np.random.choice(ratio_mn, min(int(_sage_const_100000), len(ratio_mn)), replace=False)  # CORRECCIÓN: int()
ax5.hist(sample, bins=int(_sage_const_50), color='orange', edgecolor='black', alpha=float(_sage_const_0p7))  # CORRECCIÓN: int() y float()
ax5.axvline(x=float(_sage_const_0p5), color='red', linestyle='--', label='0.5')  # CORRECCIÓN: float()
ax5.set_xlabel('Ratio m/n', fontsize=int(_sage_const_10))
ax5.set_ylabel('Frecuencia', fontsize=int(_sage_const_10))
ax5.set_title('Distribución m/n', fontsize=int(_sage_const_11), fontweight='bold')
ax5.legend()
ax5.grid(alpha=float(_sage_const_0p3), axis='y')  # CORRECCIÓN: float()

# 6. Heatmap mod 6 vs mod 8
ax6 = fig.add_subplot(gs[_sage_const_2 , :_sage_const_2 ])
heatmap = np.zeros((_sage_const_6 , _sage_const_8 ))  # CORRECCIÓN: Enteros de Python
for i in range(_sage_const_6 ):
    for j in range(_sage_const_8 ):
        mask = (valores % _sage_const_6  == i) & (valores % _sage_const_8  == j)
        heatmap[i, j] = int(np.sum(mask))

im = ax6.imshow(heatmap, cmap='YlOrRd', aspect='auto')
ax6.set_xticks(range(_sage_const_8 ))
ax6.set_yticks(range(_sage_const_6 ))
ax6.set_xlabel('Residuo mod 8', fontsize=int(_sage_const_10))
ax6.set_ylabel('Residuo mod 6', fontsize=int(_sage_const_10))
ax6.set_title('Heatmap (mod 6, mod 8)', fontsize=int(_sage_const_11), fontweight='bold')
plt.colorbar(im, ax=ax6)

# 7. Ratio u/v vs m/n
ax7 = fig.add_subplot(gs[_sage_const_2 , _sage_const_2 ])
sample_idx = np.random.choice(len(ratio_mn), min(int(_sage_const_10000), len(ratio_mn)), replace=False)  # CORRECCIÓN: int()
ax7.scatter(ratio_mn[sample_idx], ratio_uv[sample_idx], alpha=float(_sage_const_0p3), s=int(_sage_const_5))  # CORRECCIÓN: float() y int()
x = np.linspace(_sage_const_0 , _sage_const_1 , _sage_const_100 )  # CORRECCIÓN: Enteros de Python
y = _sage_const_2  - x  # CORRECCIÓN: Entero de Python
ax7.plot(x, y, 'r-', linewidth=int(_sage_const_2), label='u/v = 2 - m/n')  # CORRECCIÓN: int()
ax7.set_xlabel('m/n', fontsize=int(_sage_const_10))
ax7.set_ylabel('u/v', fontsize=int(_sage_const_10))
ax7.set_title('Relación u/v vs m/n', fontsize=int(_sage_const_11), fontweight='bold')
ax7.legend()
ax7.grid(alpha=float(_sage_const_0p3))  # CORRECCIÓN: float()

plt.savefig('analisis_modular_extensivo.png', dpi=int(_sage_const_300), bbox_inches='tight')  # CORRECCIÓN: int()
print("✓ Guardado: analisis_modular_extensivo.png")

# ============================================================================
# 10. EXPORTAR
# ============================================================================

print("\n[10] Exportando...")

with open('resumen_analisis_modular.txt', 'w', encoding='utf-8') as f:
    f.write("="*int(_sage_const_80) + "\n")  # CORRECCIÓN: int()
    f.write("ANÁLISIS MODULAR EXTENSIVO - OPERADOR k=3\n")
    f.write("="*int(_sage_const_80) + "\n\n")
    f.write(f"Dataset: {len(df):,} registros\n")
    f.write(f"Rango N: [{int(valores.min()):,}, {int(valores.max()):,}]\n\n")
    
    for mod in modulos_analisis:
        f.write(f"\nMÓDULO {mod}:\n")
        f.write("-" * int(_sage_const_40) + "\n")  # CORRECCIÓN: int()
        dist = resultados_modulares[mod]
        total = len(valores)
        for residuo in sorted(dist.keys()):
            count = int(dist[residuo])
            porc = float(_sage_const_100  * count / total)  # CORRECCIÓN: float()
            f.write(f"  {residuo:2d} ≡ (mod {mod:2d}): {count:>12,} ({porc:6.2f}%)\n")
    
    f.write(f"\n\nRATIO m/n:\n")
    f.write("-" * int(_sage_const_40) + "\n")  # CORRECCIÓN: int()
    f.write(f"  Media: {float(np.mean(ratio_mn)):.6f}\n")
    f.write(f"  Mediana: {float(np.median(ratio_mn)):.6f}\n")
    f.write(f"  Desv. estándar: {float(np.std(ratio_mn)):.6f}\n")
    f.write(f"  Skewness: {float(stats.skew(ratio_mn)):.6f}\n")

freq_data = []
for mod in modulos_analisis:
    for residuo, count in sorted(resultados_modulares[mod].items()):
        freq_data.append({
            'Modulo': int(mod),
            'Residuo': int(residuo),
            'Frecuencia': int(count),
            'Porcentaje': float(_sage_const_100  * count / len(valores))  # CORRECCIÓN: float()
        })

pd.DataFrame(freq_data).to_csv('frecuencias_modulares.csv', index=False)

print("✓ Archivos generados:")
print("  • analisis_modular_extensivo.png")
print("  • resumen_analisis_modular.txt")
print("  • frecuencias_modulares.csv")

print("\n" + "="*int(_sage_const_80))
print("ANÁLISIS COMPLETADO")
print(f"Tiempo: {float(time.time() - start_time):.2f}s")
print("="*int(_sage_const_80))


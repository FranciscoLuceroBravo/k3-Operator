

# This file was *autogenerated* from the file rank_12routes.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_1001 = Integer(1001); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_65 = Integer(65)
import pandas as pd

# 1. Definición de regímenes
regimenes = [
    ('n-1', lambda n: n - _sage_const_1 ), ('n-2', lambda n: n - _sage_const_2 ), ('n-3', lambda n: n - _sage_const_3 ), ('n-4', lambda n: n - _sage_const_4 ),
    ('m=1', lambda n: _sage_const_1 ), ('m=2', lambda n: _sage_const_2 ), ('m=3', lambda n: _sage_const_3 ), ('m=4', lambda n: _sage_const_4 ),
    ('n/2+1', lambda n: n//_sage_const_2  + _sage_const_1 ), ('n/2+2', lambda n: n//_sage_const_2  + _sage_const_2 ), ('n/2+3', lambda n: n//_sage_const_2  + _sage_const_3 ), ('n/2+4', lambda n: n//_sage_const_2  + _sage_const_4 )
]

procedencia = {}

print("Iniciando construcción de datos...")

for etiqueta, func_m in regimenes:
    for n in range(_sage_const_2 , _sage_const_1001 ):
        m = func_m(n)
        if m <= _sage_const_0  or n == m: continue 
        
        # Operador n(n-m)(2n-m)(3n-m)
        raw_N = ZZ(n * (n - m) * (_sage_const_2 *n - m) * (_sage_const_3 *n - m))
        # Normalizamos a valor absoluto para evitar curvas singulares o errores de signo
        sf_N = abs(raw_N.squarefree_part())
        
        # Filtro estricto: N debe ser > 0 para definir una curva elíptica válida
        if sf_N == _sage_const_0 : continue
        
        if sf_N not in procedencia:
            procedencia[sf_N] = [etiqueta]
        else:
            if etiqueta not in procedencia[sf_N]:
                procedencia[sf_N].append(etiqueta)

# 2. Ordenamiento y selección de los primeros 100
nucleos_ordenados = sorted(procedencia.keys())
top_100 = nucleos_ordenados[:_sage_const_100 ]

# 3. Análisis de Rango con control de errores (Skip)
resultados_rango = []

print(f"\nAnalizando rango para los primeros 100 núcleos únicos...")
print(f"{'N (SF)':<10} | {'Rango':<6} | {'Rutas de Procedencia'}")
print("-" * _sage_const_65 )

for n_val in top_100:
    try:
        # Definición de la curva elíptica y^2 = x^3 - N^2x
        E = EllipticCurve([-n_val**_sage_const_2 , _sage_const_0 ])
        # Intentamos calcular rango. Limitamos 'only_bound' si es muy complejo
        r = E.rank()
        rutas = ", ".join(procedencia[n_val])
        
        resultados_rango.append({
            'N_SF': n_val,
            'Rango': r,
            'Procedencia': rutas
        })
        print(f"{n_val:<10} | {r:<6} | {rutas}")
        
    except Exception as e:
        # Si falla el cálculo o la curva es singular, saltamos al siguiente
        print(f"{n_val:<10} | {'SKIP':<6} | {rutas} (Error: {type(e).__name__})")
        continue

# 4. Exportación a CSV
df_completo = pd.DataFrame([{'N_SF': k, 'Procedencia': ", ".join(v)} for k, v in procedencia.items()])
df_completo.to_csv('data_construida_completa.csv', index=False)

df_top100 = pd.DataFrame(resultados_rango)
df_top100.to_csv('analisis_rango_top100.csv', index=False)

print("-" * _sage_const_65 )
print(f"Proceso finalizado. Analizados {len(resultados_rango)} de {len(top_100)} núcleos con éxito.")

